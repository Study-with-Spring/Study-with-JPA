### 준영속 엔티티

엔티티는 영속성 컨텍스트에서 관리된다. 엔티티의 값이 변경되면 JPA가 트랜젝션 커밋 시점에 변경된 내용을 디비에 반영해준다. 또한 이를 변경 감지(Dirty checking) 방식이라 한다.

**준영속 엔티티란?**

영속성 컨텍스트가 더 이상 관리하지 않는 엔티티를 말한다. 준영속 상태의 엔티티는 더는 영속성 컨텍스트의 관리를 받지 못하므로 영속성 컨텍스트가 제공하는 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 같은 기능을 사용할 수 없다.

- 영속성 컨텍스트가 더 이상 관리하지 않는 엔티티 (JPA는 엔티티를 한 번 DB에 넘기면 더 이상 관리하지 않음)
- DB에 한 번이라도 저장된 적 있는 객체
- DB에 식별가능한 값(PK)을 가지고 있는 객체
- JPA가 식별할 수 있는 ID값을 가지고있는 객체
- 임의로 만들어낸 엔티티라도 기존에 식별자를 가지고있으면 준영속 엔티티로 본다.

강의에서 Book 객체가 이미 DB에 한 번 저장되어서 식별자가 존재하고, 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다는데 식별자의 유무와 영속 간에 무슨 상관이 있는지 이해가 가지 않음

→ 영속 상태가 되려면 식별자가 꼭 필요하기 때문에 모든 준영속 상태의 객체는 식별자를 가지고 있다. Book을 수정하는 프로세스의 경우 Book은 이미 한 번 영속성 컨텍스트에 저장이 되었고, 새로 new Book 객체를 만든다고 할지라고 이미 영속성 컨텍스트에 관리되던 객체를 그대로 만들어낸 것이기 때문에 준영속이라 할 수 있다.

**준영속 상태를 만드는 방법 3가지**

1. `em.detach(entity)` : 특정 엔티티만 준영속 상태로 전환
    
    메소드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.
    
2. `em.clear()` : 영속성 컨텍스트를 완전히 초기화
3. `em.close()` : 영속성 컨텍스트를 종료

비영속과 준영속의 결정적인 차이는 식별자의 유무이다.

