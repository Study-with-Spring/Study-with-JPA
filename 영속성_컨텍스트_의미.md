# JPA Study

---

**영속(Persistence)이 뭐지?**

강의를 듣다보면 데이터 영속성, 영속성 컨텍스트와 같은 말씀을 종종 하신다. 또 JPA는 Java Persistence API의 약자이고 Entity Manager에는 persist() 라는 메서드도 있다.

영속의 사전적 의미는 영원한 것, 지속적인 것이라고 한다. 한 블로그에서 이와 관련된 흥미로운 글을 보았는데, JPA에서 Persist의 의미는 자바의 객체가 JVM(Java Vertual Machine) 외에서도 지속될 수 있도록 한다는 뜻으로 접근하고 있었다. Java는 JVM이라는 세상에서 존재하고, JVM이 사라지면 java 객체도 사라진다. JPA에서는 객체를 데이터베이스에 저장하므로 객체를 JVM 밖에서도 유지되도록 하며 Entity Manager의 persist 메서드는 영속성 컨텍스트를 통해서 엔티티가 데이터베이스에 저장될 수 있도록 영속화한다 . 결론은 JPA는 persist를 JVM 외부에 객체를 유지한다는 의미로 사용한다고 유추해볼 수 있다.

### 영속성 컨텍스트

**EntityManagerFactory와 EntityManager**

- JPA는 스레드가 하나 생성될 때마다(매 요청마다) EntityManagerFactory에서 EntityManager를 생성한다.
- EntityManager는 내부적으로 DB 커넥션 풀을 사용해서 DB에 붙는다. (????? DB로 컨텍스트에 저장된 객체 정보들을 전달한다는 뜻인가)

영속성 컨텍스트는 “엔티티를 영구 저장하는 환경”이라는 뜻이다. 

- 비영속(new) : 영속성 컨텍스트와 전혀 관계가 없는 상태.
- 영속(managed) :
    - 영속성 컨텍스트에 저장된 상태
    - 엔티티가 영속성 컨텍스트에 의해 관리된다
    - 영속 상태가 된다고 DB에 쿼리가 날아가지 않으며 DB에 저장되지 않는다.
    - 트랜잭션의 커밋 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태. DB에서도 제거된다.

영속성 컨텍스트가 존재하는 이유 생각 정리

→ 왜 디비에 바로 저장하지 않고 영속성 컨텍스트를 따로 두는걸까 하는 의문이 있었는데, 데이터베이스의 트랜잭션을 공부하고나서 고민해본 결과, 영속성 컨텍스트는 트랜잭션의 ‘원자성’과 ‘일관성’을 지키기 위한 방법 중 하나라고 할 수 있다는 결론을 내릴 수 있었다. 새롭게 생성되었거나 변경된 객체 정보를 먼저 영속성 컨텍스트에 저장하였다가 트랜잭션이 정상적으로 종료되었다면 트랜잭션의 commit이 이루어지고 영속성 컨텍스트에 올라온 데이터를 DB에 안전하게 저장할 수 있다. 만약 트랜잭션이 정상적으로 종료되지 않는다면 컨텍스트의 모든 처리는 의미를 잃게되므로 영속성 컨텍스트에 올라온 데이터들 또한 rollback해야한다. 이러한 분리를 통해 일관성과 영속성을 유지하고 신뢰할 수 있는 데이터를 영구저장할 수 있다.

**데이터베이스에서의 트랜잭션(transaction)**

데이터베이스의 상태를 변화시키는 업무처리의 논리적 단위. 원자성, 일관성, 격리성을 지닌다.

************원자성(Atomicity)************

트랜잭션을 구성하는 작업들은 전부 수행이 되거나 전혀 수행이 되지 않아야 하는 특성 (ex 계좌이체 트랜잭션 도중 문제가 발생하면 안됨)

**일관성(consistency)**

일관성이란 트랜잭션을 수행하기 이전의 데이터베이스와 수행한 이후의 데이터베이스가 논리적으로 일관된 상태를 유지하는 특성을 말한다. (ex 상품 재고 수량 + 판매 수량 shoul be 판매 이전 재고 수량)

**트랜잭션 내부에서 `persist()`가 일어날 때**

- 엔티티들을 1차 캐시에 저장하고, 논리적으로 **쓰기 지연 SQL 저장소** 라는 곳에 **INSERT 쿼리들을 생성해서 쌓아 놓는다**.
- DB에 바로 넣지 않고 기다린다.
- `commit()`하는 시점에 DB에 동시에 쿼리들을 보낸다.(쿼리를 보내는 방식은 동시 or 하나씩 옵션에 따라)
- 이렇게 쌓여있는 쿼리들을 DB에 보내는 동작이 `flush()` 이다.
- `flush()` 는 1차캐시를 지우지는 않는다. 쿼리들을 DB에 날려서 DB와 싱크를 맞추는 역할을 한다.
- 실제로 쿼리를 보내고 나서, `commit()`한다.
- 트랜잭션을 커밋하게 되면, `flush() 와 commit()` 두가지 일을 하게 되는 것이다.

영속성 컨텍스트와 1, 2차 캐시 : [https://ict-nroo.tistory.com/130](https://ict-nroo.tistory.com/130)

[JPA에서 영속화라는 의미는 뭘까?](https://dev-monkey-dugi.tistory.com/131)

### References

[https://wikidocs.net/161164](https://wikidocs.net/161164)